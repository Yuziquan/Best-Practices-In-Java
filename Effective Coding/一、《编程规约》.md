[TOC]

## 一. 《编程规约》

> 根据约束力强弱和故障故障敏感性，将规约分为“强制”、“推荐”、“参考”三类。
> * 【强制】：必须遵守，违反本约定或将会引起严重的后果； 
> * 【推荐】：尽量遵守，长期遵守有助于系统稳定性和合作效率的提升； 
> * 【参考】：充分理解，技术意识的引导，是个人学习、团队沟通、项目合作的方向。

<br/>

### 1. 命名风格

#### 1.1 强制

* 所有命名不以下划线“_”或美元符号开始或结束。
* 所有命名严禁使用拼音和英文混合的方式，也禁止直接使用中文的方式。即使是纯拼音命名方式，也要避免使用）。其中，对于一些国际通用的名词，如`taobao`、`youku`、`guangzhou`，可以视为英文。
* 类名均使用UpperCamelCase风格，但对于DO/BO/DTO/VO/AO/PO等除外（比如，可以`UseDO`）。
* 方法名、方法参数名、成员变量名、局部变量名均使用lowerCamelCase风格。
* 常量名的各个字母均大写，且单词之间用下划线分隔。（力求语义完整，不要嫌名字长）
* 抽象类类名使用`Abstract`或`Base`作为前缀，异常类类名使用`Exception`作为后缀，测试类类名以它要测试的类名开始，以`Test`结尾。
* 定义数组时，使用“类型名与中括号之间无空格”的方式，如 `int[] testArray`，但 `int [] testArray` 、`String args[]`违反了该方式。
* POJO类中的布尔型变量不要以`is`为前缀，否则部分框架解析会引起序列化错误。比如，定义了一个属性`Boolean isDeleted;`，其对应的方法名也是 `isDeleted()`，RPC框架在反向解析时，就会误认为对应的属性名为`deleted` ，导致后期属性获取不到抛出异常。


* 包名均使用小写形式，点分隔符之间有且仅有一个具有自然语义的英语单词。包名均使用单数形式，但若类名有复数含义，则类名可以使用复数形式。
* 杜绝不规范的缩写，避免词不达意，避免降低代码的可读性。如，将`condition`缩写成`condi`、将`AbstractTestClass`缩写成`AbsTestClass`。

<br/>

#### 1.2 推荐

* 为了达到“代码自解释”的目标，任何自定义编程元素在命名时，尽量使用完整的单词组合来表达其意。

* 若模块、接口、类、方法使用了某个/些设计模式，则应在命名中体现出来，这也有利于阅读代码的人快速理解架构的设计理念。如`LoginProxy`、`OrderFactory`、`HelpBuilder`、`ResourceObserver`等。

* 接口类中的方法和属性前面不要加任何修饰符（public也不要加），保持代码的简洁，并加上有效的Javadoc注释。尽量不要在接口中定义变量，如果一定要，则必须是与接口方法相关的，并且是整个应用的基础常量。

  如 `public abstract void commit();`根据要求应改写为`void commit();`。

  （如果Jdk8中接口允许有默认实现，则这个default方法是对所有实现类都有价值的默认实现。）



<br/>

#### 1.3 参考

* 枚举类名带上Enum后缀，枚举成员名需全部大写，单词之间用下划线分隔。

  （枚举其实就是特殊的常量类，其构造方法被默认强制为私有的。）

* 使用分层架构时，各层的命名方式：

  - **（1）Service/DAO层的方法命名规约**

    - 获取单个对象的方法：用`get`作为前缀；
    - 获取多个对象的方法：用`list`作为前缀；
    - 获取统计值的方法：用`count`作为前缀；
    - 插入的方法：用`save/insert`作为前缀；
    - 删除的方法：用`remove/delete`作为前缀；
    - 修改的方法：用`update`作为前缀；

    <br/>

  - **（2）领域(domain)模型命名规约**

    - 数据对象：`xxxDO`，xxx为数据表名；
    - 数据传输对象：`xxDTO`，xxx为业务领域相关的名称；
    - 展示对象：`xxxVO`，xxx为网页名称；
    - POJO是`DO/DTO/BO/VO`等的统称，禁止使用POJO来命名，如~~xxxPOJO~~。

<br/>

#### 1.4 特殊说明

* 对于接口以及相应的实现类的命名，有两个规则：

  * 【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用`Impl`作为后缀与接口区分开。如`CacheServiceImpl` 实现 `CacheService`接口。
  * 【推荐】若是形容“能力/功能”的接口名称，则取对应的形容词作为接口名（通常是-able的形式）。如 `AbstractTranslator` 实现 `Translatable`。


<br/>

***


### 2. 常量定义

#### 2.1 强制

* 不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。
* ​

<br/>

#### 2.2 推荐



<br/>

#### 2.3 参考



<br/>

***

### 3. 代码格式




<br/>
***

### 4. OOP规约





<br/>

### 5. 集合处理



<br/>

***

### 6. 并发处理



<br/>

***

### 7. 控制语句

#### 7.1 强制

* 在一个switch块中，每个case要么使用break/return来终止，要么注释说明程序将继续执行到哪一个case为止。每个switch块都必须含有一个default语句，并且置于最后（即使它不含任何代码）。

* 在if/else/for/while/do语句中，必须使用大/花括号{}，即使只有一行代码，也应避免使用单行的编码方式。

* 在高并发场景下，避免使用“等于”判断作为中断或退出的条件。因为，如果没有处理好并发控制，易产生等值判断被“击穿”的情况，我们应该使用大于或小于的区间判断条件来代替。

  > eg:
  >
  > <br/>
  > 如果在某个高并发场景下，判断剩余的奖品数目等于0时，便停止发放奖品。但因为并发处理错误导致奖品数目瞬间变成了负数，这样使得活动无法停止。

* 如果不得不使用if-else if-else方式表达业务逻辑，为了避免后续代码的维护困难，不能超过三层。

<br/>

#### 7.2 推荐

* 在表达异常的分支时，尽量少用if-else方式，可以替换成以下方式：

  ```java
  if(condition)
  {
    ...
    return obj;
  }

  // 这里写else的业务逻辑代码
  ```

* 对于超过三层的if-else逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现。卫语句的例子如下：

  > eg:
  >
  > ```java
  > public void today()
  > {
  >   if(isBusy())
  >   {
  >     System.out.println("change time.");
  >     return;
  >   }
  >   
  >   if(isFree())
  >   {
  >     System.out.println("go to travel.");
  >     return;
  >   }
  >   
  >   System.out.println("stay at home.");
  >   return;
  > }
  > ```
  > * 卫语句就是将复杂的条件表达式拆分成多个条件表达式。当某个条件为真时，立刻从方法体中返回给调用方。
  > * 卫语句的优点：条件表达式之间互相独立，互不干扰。
  >
  > ​


* 不要在条件判断中执行复杂的语句（除了我们常用的getXxx、isXxx方法外），可将复杂的逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。因为很多if语句的条件判断中的逻辑表达式很复杂，包含多种逻辑运算符，理解成本高，不如单独拎出来，并定义一个容易理解的布尔变量来代表它。

  > eg:
  >
  > **正例：**
  >
  > ```java
  > final boolean existed = (file.open(name, "w") != null) && (...) || (...);
  >
  > if(existed)
  > {
  >   ...
  > }
  > ```
  >
  > **反例：**
  >
  > ```java
  > if((file.open(name, "w") != null) && (...) || (...))
  > {
  >   ...
  > }
  >
  > ```

* 对于循环体中的语句要考察其性能。以下操作应尽量移至循环体外处理：定义对象/变量、获取数据库连接。此外，循环体内应该避免进行不必要的try-catch操作，应该考虑是否能够将其移至循环体外。

* 避免使用取反逻辑运算符（!）。因为取反逻辑不利于快速理解，而且取反逻辑的写法必定存在与之对应的正向逻辑写法。


  > eg:
  >
  > **正例：**
  >
  > ```java
  > if(x < 6) 
  > {
  >   ...
  > }
  > ```
  >
  > **反例：**
  >
  > ```java
  > if(!(x >= 6))
  > {
  >   ...
  > }
  > ```

* 对于接口入参的保护，常见于用作批量操作的接口。

<br/>

#### 7.3 参考

* 需要进行参数校验的情况：
  * 被调用频次低的方法。
  * 执行时间开销很大的方法。在该情形下，参数校验的时间几乎可以忽略不计。但是要注意，若参数校验过程中因参数错误导致中间执行回退，或者错误，则得不偿失。
  * 需要极高稳定性和可用性的方法。
  * 对外提供的开放接口，不管是否为RPC/API/HTTP接口。
  * 敏感权限入口。
* 不需要进行参数校验的情况：
  * 极有可能被循环调用的方法。注意要在方法说明中注明外部参数的检查要求。
  * 底层调用频次高的方法。因为参数错误一般不大可能到底层（如DAO层）才出现问题。比如，DAO层与Service层一般在同一个应用中，并部署在同一台服务器中，故DAO的参数校验可以省略。
  * 被声明为private的、只会被自己代码所调用的方法。若可以确定被调用的方法的传入参数已经做过检查或者肯定不会有问题，则可以不进行参数校验。

<br/>

***

### 8. 注释规约

#### 8.1 强制

- 类、类属性、类成员方法的注释必须使用Javadoc规范，使用`/**内容*/` 格式，不得使用`//xxx`格式！

  因为

- ​

  ​

<br/>

#### 8.2 推荐



<br/>

#### 8.3 参考



<br/>

***

### 9. 其他











